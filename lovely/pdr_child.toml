
[manifest]
version = "1.0.0"
dump_lua = true
priority = 0

#payout screen name
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
position = "at"
pattern = """
table.insert(left_text, {n=G.UIT.O, config={object = DynaText({string = localize{type = 'name_text', set = config.card.config.center.set, key = config.card.config.center.key}, colours = {G.C.FILTER}, shadow = true, pop_in = 0, scale = 0.6*scale, silent = true})}})
"""
payload = '''
table.insert(left_text, {
    n = G.UIT.O,
    config = {
        object = DynaText({
            string = (
                config.card.config.center.key == 'j_hpot_child'
                and config.card.ability.name
                or localize{
                    type = 'name_text',
                    set = config.card.config.center.set,
                    key = config.card.config.center.key
                }
            ),
            colours = {G.C.FILTER},
            shadow = true,
            pop_in = 0,
            scale = 0.6 * scale,
            silent = true
        })
    }
})
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
position = 'at'
pattern = '''
elseif self.ability.name == 'Blueprint' then
                for i = 1, #G.jokers.cards do
                    if G.jokers.cards[i] == self then other_joker = G.jokers.cards[i+1] end
                end
            end'''
payload = '''
elseif self.ability.name == 'Blueprint' then
    local pos, area = find_self(self)
    if pos and area then other_joker = area.cards[pos + 1] end
end
'''
match_indent = true
overwrite = false

# blueprint compat for children
[[patches]]
[patches.pattern]
target = "card.lua"
position = "at"
pattern = "            if other_joker and other_joker ~= self and other_joker.config.center.blueprint_compat then"
payload = """
            if other_joker and other_joker ~= self and (other_joker.config.center.blueprint_compat or other_joker.ability.quantum_1 and other_joker.ability.quantum_2
                                                                                                                and (other_joker.ability.quantum_1.config.center.blueprint_compat
                                                                                                                    or other_joker.ability.quantum_2.config.center.blueprint_compat)) then"""
match_indent = true
overwrite = false

# blueprint compat for children ()
[[patches]]
[patches.pattern]
target = "card.lua"
position = "at"
pattern = "if G.jokers.cards[i] == self then other_joker = G.jokers.cards[i+1] end"
payload = "if G.jokers.cards[i] == (self.quantum or self) then other_joker = G.jokers.cards[i+1] end"
match_indent = true
times = 2


# Card.update for children
[[patches]]
[patches.pattern]
target = "card.lua"
position = "at"
pattern = "    if not self.states.focus.is and self.children.focused_ui then"
payload = "    if self.states and (not self.states.focus.is and self.children.focused_ui) then"
match_indent = true

# Fix order of calc keys (replicates new smods update)
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
match_indent = true
position = 'at'
pattern = '''
'level_up', 'func', 'extra',
'numerator', 'denominator',
'modify',
'no_destroy', 'prevent_trigger',
'replace_scoring_name', 'replace_display_name', 'replace_poker_hands'
'''
payload = '''
'level_up', 'func',
'numerator', 'denominator',
'modify',
'no_destroy', 'prevent_trigger',
'replace_scoring_name', 'replace_display_name', 'replace_poker_hands',
'extra'
'''

# Blueprint uses SMODS.blueprint_effect
[[patches]]
[patches.pattern]
target = 'card.lua'
match_indent = true
position = 'at'
pattern = '''
if other_joker and other_joker ~= self and not other_joker.debuff and not context.no_blueprint then
    if (context.blueprint or 0) > #G.jokers.cards then return end
    local old_context_blueprint = context.blueprint
    context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
    local old_context_blueprint_card = context.blueprint_card
    context.blueprint_card = context.blueprint_card or self
    local eff_card = context.blueprint_card
    local other_joker_ret = other_joker:calculate_joker(context)
    context.blueprint = old_context_blueprint
    context.blueprint_card = old_context_blueprint_card
    if other_joker_ret then 
        other_joker_ret.card = eff_card
        other_joker_ret.colour = G.C.BLUE
        return other_joker_ret
    end
end
'''
payload = '''
local ret = SMODS.blueprint_effect(self, other_joker, context)
if ret then
    ret.colour = G.C.BLUE
    return ret
end
'''

# Brainstorm uses SMODS.blueprint_effect
[[patches]]
[patches.pattern]
target = 'card.lua'
match_indent = true
position = 'at'
pattern = '''
if other_joker and other_joker ~= self and not other_joker.debuff and not context.no_blueprint then
    if (context.blueprint or 0) > #G.jokers.cards then return end
    local old_context_blueprint = context.blueprint
    context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
    local old_context_blueprint_card = context.blueprint_card
    context.blueprint_card = context.blueprint_card or self
    local eff_card = context.blueprint_card
    local other_joker_ret = other_joker:calculate_joker(context)
    context.blueprint = old_context_blueprint
    context.blueprint_card = old_context_blueprint_card
    if other_joker_ret then 
        other_joker_ret.card = eff_card
        other_joker_ret.colour = G.C.RED
        return other_joker_ret
    end
end
'''
payload = '''
local ret = SMODS.blueprint_effect(self, other_joker, context)
if ret then
    ret.colour = G.C.RED
    return ret
end
'''
